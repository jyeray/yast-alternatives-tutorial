---
layout: default
---

<h2>Joining the pieces</h2>

<h3>It even works!</h3>
<p>
Now we are ready to join the parts, and as a result we will hava a module where
we can see all the alternatives on the system and filter them.
</p>
<p>
As usual, let's start fetching the proposed solution by running the following
command in our local copy.
</p>
{% highlight bash %}
git checkout fully_working
{% endhighlight %}
<p>
Play a little bit with the result (both as a regular user and as root) before
diving into the code.
</p>

<h3>From mockup to reality</h3>
<p>
In the original mockup there was no binding between the widgets and
any real information coming from the system or the user. Now the
ListAlternatives object keeps three instance variables to store that information.
</p>
<ul>
  <li>@alternatives_list is an array of Alternative object obtained from .all
    method from the Alternative class</li>
  <li>@multi_choice_only is a boolean to filter the alternatives with only one
    choice, is setted by the user using the checkbox.</li>
  <li>@search is the string used to filter the displayed alternatives, entered
    by the user in the corresponding text input field.</li>
</ul>
<p>
In addition, another subtle but meaningful change has be done by renaming the
client from mockup.rb to alternatives.rb.
</p>

<h3>A more interactive interface</h3>
<p>
As opposed to the mockup, in which only contained an empty table and the only
possible interaction was to close the dialog, our module now shows the existing
alternatives in the system and and react to many events, like shown in the new
event loop.
</p>
{% highlight ruby %}
def event_loop
  loop do
    case Yast::UI.UserInput
    when :cancel
      # Break the loop
      break
    when :accept
      # Break the loop
      break
    when :multi_choice_only
      read_multi_choice_only
      redraw_table
    when :search
      read_search
      redraw_table
    else
      log.warn "Unexpected input."
    end
  end
end
{% endhighlight %}
<p>
The loop relies on two private methods to set the value of the instance
variables (unsurprisingly called read_search and read_multi_choice_only) and one
method called redraw_table used to update the user interface.
</p>
<p>
Let start with the latter. The method redraw_table is just a one-liner that uses
the ChangeWidget function to alter the :Items property of the widget with the
identifier :alternatives_table.
</p>
{% highlight ruby %}
def redraw_table
  Yast::UI.ChangeWidget(:alternatives_table, :Items, map_alternatives_items)
end
{% endhighlight %}
<p>
As you may have already guessed, the same function can be used not only to
change the list of items in other type of widgets (like a combo box), but also
to change other properties like the status of a widget (:Enabled), its label
(:Label), its content (:Value), the selected item (:CurrentItem) and many more.
</p>
<p>
But besides changing the interface to reflect the changes, we also need to read
the content of the widgets. The simplest example is the read_search method
used to set the value of @search reading it from the corresponding input field.
The read_multi_choice_only method works in the same way.
</p>
{% highlight ruby %}
def read_search
  @search = Yast::UI.QueryWidget(:search, :Value)
end
{% endhighlight %}
<p>
The rest of the code in the proposed solution does not rely in any specific
YaST feature and, thus, it should be pretty straightforward to read and
understand.
</p>
<h3>Show your achievements to the world</h3>
<p>
We finally have a fully working YaST module. It's time to install it in our
system and to release it for others to enjoy and test. Even whether you feel
that your module is not yet ready for production usage, you must never forget
the &quot;release early, release often&quot; principle. The
<a href="step7.html">last step</a> of the tutorial will teach you everything
you need to know in order to ship your YaST modules.
</p>
