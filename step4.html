---
layout: default
---

<h2>Automation and testing</h2>

<h3>The YaST rake tasks</h3>
<p>
During the introduction section of this tutorial we used a rake task to execute
our YaST module. This and many other tasks are provided by the
<a href="https://rubygems.org/gems/yast-rake">yast-rake gem</a>. We already have
the gem installed in our system, so adding a very simple Rakefile will
immediately supercharge our prototype. To checkout that file, simply run:
</p>
{% highlight bash %}
git checkout rakefile
{% endhighlight %}
<p>
As you can see, the new Rakefile contains only the following line.
</p>
{% highlight ruby %}
require "yast/rake"
{% endhighlight %}
<p>
That's enough to add all the YaST rake tasks to our module. As usual, you can
ask rake to list all the available tasks.
</p>
{% highlight bash %}
rake -T
{% endhighlight %}
<p>
Now, let's try some of the useful available tasks. But first we need to install
"rubygem-gettext".
</p>
{% highlight bash %}
ruby_version=$(ruby -e "puts RbConfig::CONFIG['ruby_version']")
zypper install -C "rubygem(ruby:$ruby_version:gettext)"
{% endhighlight %}
<p>
Now we can use this three very simple but handy tasks to check our code.
</p>
{% highlight bash %}
rake check:license
rake check:pot
rake check:syntax
{% endhighlight %}
<p>
As you already know, there are also tasks for running the software. One for
executing our mockup client and another one for invoking a Ruby interpreter with
our code already pre-loaded.
</p>
{% highlight bash %}
rake run
rake console
{% endhighlight %}
<p>
You can paste the following example code directly into the interpreter opened by
&quot;rake console&quot; and everything will work out of the box.
</p>
{% highlight ruby %}
require "y2_alternatives/alternative.rb"

choices = [
            Y2Alternatives::Alternative::Choice.new("/usr/bin/nano", "20"),
            Y2Alternatives::Alternative::Choice.new("/usr/bin/vim", "30")
          ]
alternative = Y2Alternatives::Alternative.new("editor", "manual", "vim", choices)

puts "The alternative #{alternative.name} is on #{alternative.status} and have the value #{alternative.value}"
{% endhighlight %}
<p>
As mentioned, we will explore other tasks (mostly related to packaging) in an
upcoming step, but first we need to finish our prototype.
</p>

<h3>The RSpec tests</h3>
<p>
Of course, no Ruby class is complete without the corresponding unit tests.
Thus we need unit tests for our Alternative, AutomaticModeCommand and
SetChoiceCommand classes before proceeding with any further action. As many
other Ruby-based projects, YaST uses <a href="http://rspec.info/">RSpec</a>
(version 2 at the time of writing) for unit testing. In the
<a href="http://yast.github.io/guidelines.html">guidelines section</a> of the
YaST home page you will find some recommendations for writing YaST tests.
</p>
<p>
To checkout some example unit tests for our models run the following command.
</p>
{% highlight bash %}
git checkout unit_tests
{% endhighlight %}
<p>
Before running the tests, make sure you have RSpec installed. You can install
it using zypper:
</p>
{% highlight bash %}
ruby_version=$(ruby -e "puts RbConfig::CONFIG['ruby_version']")
zypper install -C "rubygem(ruby:$ruby_version:rspec)"
{% endhighlight %}
<p>
Under the &quot;test&quot; directory you will find the corresponding RSpec
unit tests for Alternative, AutomaticModeCommand and SetChoiceCommand. Those
tests are just a simple example and are not completely exhaustive. Feel free to
implement any additional check. You can run the tests using the following YaST
rake task.
</p>
{% highlight bash %}
rake test:unit
{% endhighlight %}
<p>
This will execute RSpec with all the files located in the &quot;test&quot;
directory with a name ending with &quot;_test.rb&quot; or &quot;_spec.rb&quot;.
This task is crucial in the development work-flow of any YaST module. It's
always executed before building a package and before integrating any pull
request into the repositories, so better make sure that your module always
contains a comprehensive and updated suite of unit tests. Moreover, the unit
tests are considered by some YaST developers as the only authoritative
documentation for the programming interface of a class (since they are by
definition always up-to-date).
</p>
<p>
Let's take a look to the implementation of the provided example test suite.
To ensure that all the classes, modules and clients defined in our code
are available during the tests (in a predictable path), we use the same trick
that we used for running the mockup on previous steps - setting the Y2DIR
environment variable. Thus, the first line of the spec_helper.rb file included
in every test looks like this.
</p>
{% highlight ruby %}
ENV["Y2DIR"] = File.expand_path("../../src", __FILE__)
{% endhighlight %}
<p>
When writing YaST tests is very important to
<a href="http://www.rubydoc.info/gems/rspec-mocks/">stub</a> the usage of
Cheetah commands. Otherwise, they will perform their operations on the system
running the tests, which can lead to inconsistent results and even big troubles
if these operations involve something more dangerous than changing the status of
an alternative.
</p>
{% highlight ruby %}
def alternatives_pip_stub
  allow(Cheetah).to receive(:run).with(
    "update-alternatives", "--query", "pip", stdout: :capture
  ).and_return(
    "Name: pip\n" \
      "Link: /usr/bin/pip\n" \
      "Status: auto\n" \
      "Best: /usr/bin/pip3.4\n" \
      "Value: /usr/bin/pip3.4\n" \
      "\n" \
      "Alternative: /usr/bin/pip3.4\n" \
      "Priority: 30\n" \
  )
end
{% endhighlight %}
<p>
The following code extracted from alternative_spec.rb shows how the above
helper method can then be used (also it can be used together with other methods
defined in spec_helper.rb) to write safe specs that simulate the underlying
system.
</p>
{% highlight ruby %}
describe ".load" do
  subject(:loaded_alternative) { Y2Alternatives::Alternative.load("pip") }
  subject(:alternative_with_slaves) { Y2Alternatives::Alternative.load("editor") }

  it "returns an Alternative object" do
    alternatives_pip_stub
    expect(loaded_alternative).to be_an Y2Alternatives::Alternative
  end

  it "initializes the name, status and value" do
    alternatives_pip_stub
    expect(loaded_alternative).to have_attributes(
      name: "pip", status: "auto", value: "/usr/bin/pip3.4"
    )
  end
{% endhighlight %}

<h2>Almost there</h2>
<p>
Now we can finally say that we have all the pieces: tested models, a user
interface and all the necessary tools. Only <a href="step5.html">one step</a>
away from our first fully-functional YaST module (and two steps away
from the end of the training).
</p>
