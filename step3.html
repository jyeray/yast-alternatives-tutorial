---
layout: default
---

<h2>Communication with the underlying system</h2>

<h3>The available tools</h3>
<p>
Having completed the previous steps, we now have a clear view on how the
interface will look like. The next logical step is to get some data to display
there. To achive that it is necessary to read the output of update-alternative
command and parse the information to objects in our module. Fortunately exist a
tool to execute any command and get the result very easily, this tool is
<a href="https://github.com/openSUSE/cheetah">Cheetah</a>. As it is said on
Cheetah's github to install it only is necessary to execute the following command.
</p>
{% highlight bash %}
gem install cheetah
{% endhighlight %}
<p>
Once cheetah is installed, you can verify that it is true, its very simple to
execute commands. For example it is possible to extract a .tar in the following
way.
</p>
{% highlight bash %}
Cheetah.run("tar", "xzf", "foo.tar.gz")
{% endhighlight %}
<p>
But what happens if it is necessary to get some information not only execute a
command? Cheetah also allows that.
</p>
{% highlight bash %}
output_ls = Cheetah.run("ls", "la", stdout: :capture)
{% endhighlight %}

<h3>The Y2Alternatives::Alternative class</h3>
<p>
Now we are ready to implement a class representing an alternative and offering
methods to load from the system. Feel free to design and implement your our
solution. You can find the proposed one in "src/lib/y2_alternatives/alternative.rb"
right after executing:
</p>
{% highlight bash %}
git checkout domain_models
{% endhighlight %}
<p>
As you can see, the alternative class have two public class methods, "self.all"
and "self.load", the first returns an array with alternative objects representing
all the alternatives that exists in the system, and the second return a specific
alternative object with the given name. The most challenging part of this class
is to parse the obtained data from the execution of the "update-alternatives"
command to alternatives objects.
</p>
{% highlight ruby %}
# @return [Array<String>] an array with the names of the alternatives.
def self.all_names
  raw_data = Cheetah.run("update-alternatives", "--get-selections", stdout: :capture).lines
  raw_data.map { |string| string.split.first }
end

# @return [Array<Alternative>] an array with all alternatives.
def self.all
  all_names.map { |name| load(name) }
end

# @return [Alternative] an alternative with the given name.
# @param name [String] The name of the alternative to be loaded.
def self.load(name)
  raw_data = Cheetah.run("update-alternatives", "--query", name, stdout: :capture).lines
  return EmptyAlternative.new(name) unless raw_data.include?("\n")
  alternative = parse_to_map(raw_data.slice(0..raw_data.find_index("\n")))
  choices = raw_data.slice(raw_data.find_index("\n") + 1..raw_data.length)
  new(
    alternative["Name"],
    alternative["Status"],
    alternative["Value"],
    load_choices_from(choices)
  )
end
{% endhighlight %}
<p>
But that is not all, we need to keep in mind that our target with this module is
to manage the update-alternatives switching. And exists two possible actions
that the user could do with every alternative, change the current choice to
another one, and set the mode in automatic. The following methods offer these
options.
</p>
{% highlight ruby %}
def choose!(new_choice_path)
  if !choices.map(&:path).include?(new_choice_path)
    raise "The alternative doesn't have any choice with path '#{new_choice_path}'"
  end
  @value = new_choice_path
  @status = "manual"
  @modified = true
end

def automatic_mode!
  @status = "auto"
  @value = choices.sort_by { |choice| choice.priority.to_i }.last.path
  @modified = true
end
{% endhighlight %}
<p>
Note that these methods doesn't modify the alternatives in the system, only the
object in memory. This is because the typical YaST flow, first the user make the
changes, and when the user click the Accept button, these changes are saved in
the system.
</p>
<p>To follow this way, the methods avobe put the "@modified" flag to
true. This flag will be checked in the method below, which responsability is to
save in the system the changes made to the alternative.
</p>
{% highlight ruby %}
def save
  return unless @modified
  STATUS_COMMANDS[@status].execute(self)
end
{% endhighlight %}
<p>
After check that the alternative has been modified, the save method execute one
of the existing commands depending on the changes made to the alternative. These
commands are two, one for set a choice and the other to set the automatic mode.
Let's see those commands.
</p>
{% highlight ruby %}
require "cheetah"

module Y2Alternatives
  module Control
    # Command to change the selected choice of an alternative.
    class SetChoiceCommand
      def self.execute(alternative)
        Cheetah.run("update-alternatives", "--set", alternative.name, alternative.value)
      end
    end
  end
end
{% endhighlight %}
{% highlight ruby %}
require "cheetah"

module Y2Alternatives
  module Control
    # Command to set an alternative in automatic mode.
    class AutomaticModeCommand
      def self.execute(alternative)
        Cheetah.run("update-alternatives", "--auto", alternative.name)
      end
    end
  end
end
{% endhighlight %}
<p>
As you can see both are pretty similar and simple, only one method that execute
a Cheetah call.
</p>
<h3>Laying the foundation</h3>
<p>
We already have a basic user interface and some domain models capable of reading
the information we need from the system. But before starting to put both things
together we need to ensure that we are standing on solid ground.
</p>
<p>
First of all, we obviously need to write unit tests for our new models.
Moreover, it would be nice to have some tools to check that our code can be
properly executed and complies with the YaST standards.
</p>
<p>
So before we continue writing code, let's take a look to the available YaST
development tools in the <a href="step4.html">next step</a> of the tutorial.
</p>
