---
layout: default
---

<h2>Communication with the underlying system</h2>

<h3>The available tools</h3>
<p>
Having completed the previous steps, we now have a clear view on how the
interface will look like. The next logical step is to get some data to display
there. To achive that it is necessary to read the output of update-alternative
command and parse the information to objects in our module. Fortunately exist a
tool to execute any command and get the result very easily, this tool is
<a href="https://github.com/openSUSE/cheetah">Cheetah</a>. As it is said on
Cheetah's github to install it only is necessary to execute the following command.
</p>
{% highlight bash %}
gem install cheetah
{% endhighlight %}
<p>
Once cheetah is installed, you can verify that it is true, its very simple to
execute commands. For example it is possible to extract a .tar in the following
way.
</p>
{% highlight bash %}
Cheetah.run("tar", "xzf", "foo.tar.gz")
{% endhighlight %}
<p>
But what happens if it is necessary to get some information not only execute a
command? Cheetah also allows that.
</p>
{% highlight bash %}
output_ls = Cheetah.run("ls", "la", stdout: :capture)
{% endhighlight %}

<h3>The Y2Alternatives::Alternative class</h3>
<p>
Now we are ready to implement a class representing an alternative and offering
methods to load from the system. Feel free to design and implement your our
solution. You can find the proposed one in "src/lib/y2_alternatives/alternative.rb"
right after executing:
</p>
{% highlight bash %}
git checkout domain_models
{% endhighlight %}
<p>
As you can see, the alternative class have two public class methods, "self.all"
and "self.load", the first returns an array with alternative objects representing
all the alternatives that exists in the system, and the second return a specific
alternative object with the given name. The most challenging part of this class
is to parse the obtained data from the execution of the "update-alternatives"
command to alternatives objects.
</p>
{% highlight ruby %}
# @return [Array<String>] an array with the names of the alternatives.
def self.all_names
  raw_data = Cheetah.run("update-alternatives", "--get-selections", stdout: :capture).lines
  raw_data.map { |string| string.split.first }
end

# @return [Array<Alternative>] an array with all alternatives.
def self.all
  all_names.map { |name| load(name) }
end

# @return [Alternative] an alternative with the given name.
# @param name [String] The name of the alternative to be loaded.
def self.load(name)
  raw_data = Cheetah.run("update-alternatives", "--query", name, stdout: :capture).lines
  return EmptyAlternative.new(name) unless raw_data.include?("\n")
  alternative = parse_to_map(raw_data.slice(0..raw_data.find_index("\n")))
  choices = raw_data.slice(raw_data.find_index("\n") + 1..raw_data.length)
  new(
    alternative["Name"],
    alternative["Status"],
    alternative["Value"],
    load_choices_from(choices)
  )
end
{% endhighlight %}
<h3>Laying the foundation</h3>
<p>
We already have a basic user interface and some domain models capable of reading
the information we need from the system. But before starting to put both things
together we need to ensure that we are standing on solid ground.
</p>
<p>
First of all, we obviously need to write unit tests for our new models.
Moreover, it would be nice to have some tools to check that our code can be
properly executed and complies with the YaST standards.
</p>
<p>
So before we continue writing code, let's take a look to the available YaST
development tools in the <a href="step4.html">next step</a> of the tutorial.
</p>
