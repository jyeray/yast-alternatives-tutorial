---
layout: default
---

<h2>Communication with the underlying system</h2>

<h3>The available tools</h3>
<p>
Having completed the previous steps, we now have a clear view on how the
interface will look like. The next logical step is to get some data to display
there. To achive that it is necessary to read the output of update-alternative
command and parse the information to objects in our module. Fortunately exist a
tool to execute any command and get the result very easily, this tool is
<a href="https://github.com/openSUSE/cheetah">Cheetah</a>. As it is said on
Cheetah's github to install it only is necessary to execute the following command.
</p>
{% highlight bash %}
gem install cheetah
{% endhighlight %}
<p>
Once cheetah is installed, you can verify that it is true, its very simple to
execute commands. For example it is possible to extract a .tar in the following
way.
</p>
{% highlight bash %}
Cheetah.run("tar", "xzf", "foo.tar.gz")
{% endhighlight %}
<p>
But what happens if it is necessary to get some information not only execute a
command? Cheetah also allows that.
</p>
{% highlight bash %}
output_ls = Cheetah.run("ls", "la", stdout: :capture)
{% endhighlight %}

<h3>The Journalctl::Entry class</h3>
<p>
Taking into consideration all the above information, looks like we have in our
toolbox everything we need in order to implement a class representing
systemd journal entries and offering methods to retrieve them from the
target system. Feel free to design and implement your our solution. You can
find the proposed one in &quot;src/lib/journalctl/entry.rb&quot; right after
executing:
</p>
{% highlight bash %}
git checkout domain_models
{% endhighlight %}
<p>
As you can see, the public interface offered by this class is very simple, just
a class method called &quot;all&quot; which will return an array of Entry
objects and some attribute readers for the relevant information of each entry.
The only method containing YaST-specific code is &quot;journalctl_output&quot;,
which relies on the abovementioned Target SCR agent. The proposed solution
includes some handling for known journalctl errors.
</p>
{% highlight ruby %}
JOURNALCTL = "LANG=C journalctl --no-pager -o json"

# Handles the journalctl call
#
# @param args [String] arguments to journalctl
# @return [String] command output
def self.journalctl_output(args)
  cmd = "#{JOURNALCTL} #{args}".strip
  path = Yast::Path.new(".target.bash_output")
  cmd_result = Yast::SCR.Execute(path, cmd)

  if cmd_result["exit"].zero?
    cmd_result["stdout"]
  else
    if cmd_result["stderr"] =~ /^Failed to .* timestamp:/
      # Most likely, journalctl bug when an empty list is found
      ""
    else
      raise "Calling journalctl failed: #{cmd_result["stderr"]}"
    end
  end
end
{% endhighlight %}

<h3>The Journalctl::Query class</h3>
<p>
Using the Entry class directly would require to know the syntax of the
journalctl arguments. In order to abstract the details and also as a way to
provide some introspection capabilities for the user interface, a
Journalctl::Query class is implemented in
&quot;src/lib/journalctl/query.rb&quot;. The usage is again quite simple, as
shown by the following example.
</p>
{% highlight ruby %}
require "journalctl/query"

query = Journalctl::Query.new(boot: -1, priority: 5)
puts "First entry's process: #{query.entries.first.process_name}"
puts "Using priority #{query.filters[:priority]}"
{% endhighlight %}
<p>
This looks like good API to support not only the user interface we designed in
the previous steps but also any other Ruby code needing access to the systemd
journal. &quot;But is that enough?&quot; you may wonder. After all, YaST is a
multi-language beast and maybe you should provide a YCP interface for your
journalctl wrapper to be used from other programming languages. Fortunately,
the answer is that you don't have to worry about it. YCP is still a core
technology for YaST, but it's considered legacy. Ruby is the future of
YaST and thus all new code is expected to focus only in Ruby and its ecosystem.
</p>

<h3>Laying the foundation</h3>
<p>
We already have a basic user interface and some domain models capable of reading
the information we need from the system. But before starting to put both things
together we need to ensure that we are standing on solid ground.
</p>
<p>
First of all, we obviously need to write unit tests for our new models.
Moreover, it would be nice to have some tools to check that our code can be
properly executed and complies with the YaST standards.
</p>
<p>
So before we continue writing code, let's take a look to the available YaST
development tools in the <a href="step5.html">next step</a> of the tutorial.
</p>
